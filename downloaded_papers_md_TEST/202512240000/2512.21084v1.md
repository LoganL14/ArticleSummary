## Verification of E-Voting Algorithms in Dafny

Robert B√ºttner, Fabian Franz Die√ül, Patrick Janoschek, Ivana Kostadinovic, Henrik Oback,

Kilian Vo√ü, Franziska Alber, Roland Herrmann, Sibylle M√∂hle, Philipp R√ºmmer

University of Regensburg

Regensburg, Germany properties of the voting procedures. Extracting executable programs from the verified Dafny methods, the implementations are used to set up an e-voting web service. 1

## 2 Related Work

There exists a wealth of work concerned with different aspects of e-voting algorithms. In social choice theory, the focus is on general properties of electoral systems rather than on verifying actual implementations of voting procedures. Rossetta [25] verified anonymity, monotonicity, and concordance using Isabelle/HOL [22], and Holliday et al. [16] provided a formalization in Lean [9] for verifying general properties as well as properties inherent to specific voting systems, such as Condorcet consistency. In contrast to the work presented here, no executable prototype is available.

Afurther focus is on security-related aspects, e.g., privacy, verifiability, and coercion-resistance. A formal verification of the Estonian e-voting protocol using the Tamarin theorem prover [21] has been presented by Baloglu et al. [4]. Similarly, the Norwegian e-voting algorithm has been formalized by Cortier and Wiedling [8] in the applied-pi calculus [1]. Campanelli et al. [7] have implemented a mobile e-voting application and formally verified it using the partial model checker PaMoChSA [19], focusing on the mobility property.

Meghzili et al. [20] have adopted blockchain technology in their implementation of an e-voting system. The system was formalized by means of a hierarchical colored Petri net [17]. Blockchain technology may increase the robustness of the voting process and has been adopted in several countries. An overview can be found in the survey by Vladucu et al. [30].

## 3 Electoral Systems and Algorithms

Electoral systems provide formal rules for aggregating individual preferences into a collective outcome, and different systems may yield very different results depending on their design [23]. Electronic voting refers to the use of digital technologies to conduct elections, with the aim of making the process more efficient, accessible, and scalable while still preserving the essential properties of fairness, accuracy, and voter anonymity [2].

When designing or analyzing electoral systems, one is typically interested in properties such as determinism (the procedure produces a unique, well-defined result), correctness

1 A collection of both projects with infrastructure as well as aggregated Dafny sources can be found here: https://github.com/uuverifiers/e-voting .

## Abstract

Electronic voting procedures are implementations of electoral systems, making it possible to conduct polls or elections with the help of computers. This paper reports on the development of an open-source library of electronic voting procedures, which currently covers Score Voting, Instant-Runoff Voting, Borda Count, and Single Transferable Vote. The four procedures, of which two are discussed in detail, have been implemented in Dafny, formally verifying the consistency with functional specifications and key correctness properties. Using code extraction from the Dafny implementation, the library has been used to set up a voting web service.

## 1 Introduction

Elections and voting are fundamental mechanisms for collective decision making in modern societies. While elections are traditionally carried out by analog means such as casting paper ballots and manual counting, they are today increasingly implemented through electronic voting ( e-voting ), making it possible for voters to cast their votes on a computer, or online, and automating the process of counting the votes. The correctness of e-voting procedures is therefore crucial, as bugs in the algorithms or implementations could lead to votes not being represented correctly in the results of an election, compromising trust in the elections themselves [13, 24, 26].

There is a growing body of research on formally verifying properties of the electoral systems realized by e-voting procedures. However, relatively little work has focused on verifying the actual implementations of e-voting systems. In this paper, we report on a project developing a Dafny [18] library of verified e-voting procedures, which currently includes the single-winner methods Score Voting [27], Instant-Runoff Voting [29], and Borda Count [10], as well as the proportional Single Transferable Vote [28] method. The four algorithms cover a broad spectrum of electoral systems, providing a representative basis for exploring the benefits and challenges of applying formal verification techniques to e-voting.

Contributions. We present an open-source library implementing four e-voting algorithms, of which two (InstantRunoff Voting and Single Transferable Vote) are discussed in detail in this paper. To the best of our knowledge, the library provides the first Dafny programs for e-voting. The correctness of all four implementations was shown against a declarative functional description of the respective electoral scheme. In addition, we formally verified several end-to-end

(the implementation conforms to the mathematical definition of the algorithm), fairness (voters' preferences are taken into account according to the rules), and robustness (the system behaves predictably even in corner cases, such as ties). Formal verification offers a principled approach to establishing such properties at the level of executable code, thereby eliminating the risk of subtle implementation errors [31].

In what follows, we give a high-level overview of the four voting methods, highlighting their differences.

Score Voting. Each voter assigns a numerical score to each candidate within a fixed range. The scores are summed across all ballots, and the candidate with the highest total is declared the winner. This method allows voters to express both their order of preference and the intensity of their support, providing more nuanced information than simple rankings or approvals [27].

Instant-Runoff Voting (IRV). Voters provide a ranking, which forms a strict and total order over a subset of candidates. If no candidate obtains a majority of first-choice votes, the candidates with the fewest of such votes are eliminated. Ballots that ranked these candidates first are transferred to the next available preference. This elimination and redistribution process continues until one candidate reaches a majority or all candidates are eliminated. IRV emphasizes majority support but can be sensitive to the order of eliminations [29].

Borda Count. Each voter submits a ranking (like the one used in IRV). The algorithm then assigns points to the selected candidates according to their position in this ranking: with ùëõ candidates, the highest-ranked candidate receives ùëõ points, the second ùëõ -1, and so on, down to 1 for the last position. The points are summarized on all ballots, and the candidate with the highest score wins. To handle ties, an optional variant of Baldwin's method [3, 29] may be applied. Oncreating an election, a parameter determines the maximal number of tied placements (starting from the first place) to be resolved. The lowest-scoring candidates are then progressively eliminated from the rankings until a unique outcome is obtained. Borda Count takes full ranking into account and tends to favor broadly acceptable candidates [10].

Single Transferable Vote (STV). This is a multi-winner system, where a specified number of seats gets filled with a subset of candidates. Voters provide a ranking as in IRV. A quota is computed to determine how many votes are required for an election. Candidates reaching the quota are elected, and if they receive more votes than necessary, the surplus is redistributed fractionally according to the next preferences, using Gregory's method [11, 15]. If no candidate meets the quota, the one with the fewest votes is eliminated, and their votes are transferred. This procedure continues until all seats are filled. STV provides proportional representation and thus ensures that minority groups have fair representation within the seats [28].

## 4 Voting Procedures in Dafny

In the subsequent sections, a brief overview of the implementation and verification process is presented, followed by a more detailed examination of the Instant-Runoff Voting and Single Transferable Vote algorithms.

## 4.1 Methodology and Design Decisions

The first step was the development of pseudo-code specifications that capture the essential functionality of each algorithm while remaining close enough to an executable form to later serve as the foundation for the Dafny implementation. In addition, several design decisions had to be made regarding the representation of candidates and votes in Dafny. Candidates are represented as natural numbers. For the representation of votes, two distinct data structures were employed to account for the differing ways in which the algorithms process voter preferences:

```
type Votes_Score = seq<map<nat,int>>; type Votes_PreferenceList = seq<seq<nat>>;
```

In the first data structure, which is used in Score Voting, each vote is a map from candidates (natural numbers) to integers. Borda Count, IRV, and STV use the second one, where each vote is a preference list of candidates in descending order, with the highest-ranking candidates appearing first.

For the more complex algorithms, the pseudo-code was decomposed into smaller sub-methods. This separation reduced the difficulty of reasoning about these specific algorithms by isolating intricate behavior into smaller verifiable components, a common approach in modular verification [31]. It also facilitated collaboration within the team, as different members focused on different sub-parts of the algorithms without interfering with other colleagues.

Once the pseudo-code design was completed, the development process moved on to the implementation in Dafny. For the majority of the sub-methods, a functional model and a concrete implementation were provided and proven consistent. This approach guarantees that the executable code adheres to the higher-level specification. For larger methods that combined several sub-components, Dafny struggled with purely functional formulations. In these cases, postconditions and invariants were the key to establish correctness.

After verification was achieved at the Dafny level, Dafny's code extraction capabilities were used to generate executable implementations in C# and Go. This allowed the integration of the verified algorithms into an e-voting web sevice without sacrificing performance or usability, while still retaining the formal guarantees established during verification.

## 4.2 Algorithm 1: Instant-Runoff Voting

The verification of the Instant-Runoff Voting algorithm showcases the basics of how the verification of an election algorithm with successive elimination rounds can be accomplished.

Algorithm. The result of an election is determined by applying the steps below on the candidates ( set&lt;nat&gt; ) and votes ( Votes\_PreferenceList , see Sect. 4.1). The candidates are represented as set&lt;nat&gt; to guarantee that the order of candidates cannot influence the winner and to avoid duplicate candidates by construction. The algorithm consists of the following steps:

1. Calculate obtained votes per candidate (how many times a candidate was given as first preference).
2. If some candidate got an absolute majority, they are declared the winner and the algorithm terminates. Else, gather the candidates who got the lowest votes.
3. Update candidates and votes by removing the lowestscoring candidates. Evaluate the next voting round, by repeating the steps above until either a winner is found or all candidates are removed, resulting in no winner.

Specification. The method InstantRunoffVoting computes the result of an election and returns either the candidate who wins or 0 to indicate no winner exists.

```
1 method InstantRunoffVoting(cands: set<nat>, 2 votes: Votes_PreferenceList) returns (winner: nat) 3 requires forall i,j:: (0<=i<|votes| && 4 0<=j<|votes[i]|) ==> votes[i][j] in cands 5 requires forall i,j,k:: 6 (0<=i<|votes| && 0<=k<|votes[i]| && 7 0<=j<|votes[i]| && k!=j) 8 ==> votes[i][j] != votes[i][k] 9 requires 0 !in cands 10 ensures |votes| == 0 ==> winner == 0 11 ensures cands == {} ==> winner == 0 12 ensures winner != 0 ==> winner in cands 13 ensures winner == 0 && |cands|!=0 ==> 14 (forall c:: (c in cands) 15 ==> !isWinner_IRV(c, cands , votes)) 16 ensures winner !=0 ==> 17 isWinner_IRV(winner , cands , votes) 18 {...} 2
```

The preconditions of the InstantRunoffVoting method enforce that all votes are for existing candidates, no preference list contains duplicate candidates and 0 cannot be a candidate, so it can be safely returned to signal that no winner exists (lines 3-9). The postconditions ensure that no winner can exist if either no votes or no candidates (lines 1011) are given and that a returned winner is an existing candidate (line 12).

The hardest part of the verification was to correctly specify the different voting rounds, as the naive approach of returning the election winner or 0 in one step proved to be difficult. Instead, the code argues about candidates individually, using isWinner\_IRV (lines 13-17), which returns true if a specific candidate wins the election.

2 Code manually reformatted for presentation.

```
19 ghost function isWinner_IRV( 20 candToCheck: nat, cands: set<nat>, votes: 21 Votes_PreferenceList) : (isWinner: bool) 22 ... 23 ensures !isWinner && cands != {} ==> 24 !hasMajority_IRV(candToCheck , cands , votes) 25 ensures !isWinner && cands != {} ==> 26 hasWinnerInCurrentRound_IRV(cands, votes) 27 || candToCheck in lowestCands_IRV(cands, votes) 28 || !isWinner_IRV(candToCheck , 29 cands -lowestCands_IRV(cands , votes), 30 votesWithRemovedCandidates_IRV(cands, votes , 31 lowestCands_IRV(cands, votes))) 32 ensures isWinner ==> |votes|!=0 &&( 33 hasMajority_IRV(candToCheck , cands , votes)||( 34 candToCheck !in lowestCands_IRV(cands, votes) 35 && isWinner_IRV(candToCheck , 36 cands -lowestCands_IRV(cands , votes), 37 votesWithRemovedCandidates_IRV(cands, votes , 38 lowestCands_IRV(cands, votes)))))
```

The most important postconditions specify this behavior by checking if a candidate got an absolute majority in the current voting round or by recursively calling isWinner\_IRV to see if they win the next voting round with updated votes and candidates. If a candidate does not win, they must not have an absolute majority in the current round (lines 23-24). Additionally, either someone else wins in the current round, the candidate gets eliminated in this round, or they are not a winner in the next voting iteration (lines 25-31). If the candidate wins, then they must have an absolute majority in the current round, or they do not get eliminated in this round and are a winner in the next voting iteration (lines 32-38).

Implementation Details. Removing lowest-voted candidates from the votes serves as a good example of how components of the algorithm are verified. The desired result for a single preference list after removing the candidates is specified by singleVoteWithRemovedCands\_IRV . The correct removal is achieved by iterating over all preference lists, guaranteeing that the candidates were correctly removed from the lists already encountered (lines 44-48). For a single preference list, a nested while loop iterates over all candidates, only keeping the candidates not supposed to be removed (lines 50-53).

```
39 method VotesWithRemovedCands_IRV( 40 fullCands: set<nat>, votes: Votes_PreferenceList , 41 candsToRemove: set<nat>) 42 returns (newVotes:seq<seq<nat>>) 43 ... {... 44 while (i<|votes|) 45 ... 46 invariant forall j:: (0<=j<i) ==> newVotes[j] == 47 singleVoteWithRemovedCands_IRV( 48 fullCands , votes[j], candsToRemove) 49 {... 50 while (j<|votes[i]|)
```

```
51 invariant newVote == 52 singleVoteWithRemovedCands_IRV( 53 fullCands , votes[i][..j], candsToRemove) 54 {...} ...}}
```

An important design decision was to keep votes that no longer contain candidates as empty votes, instead of removing them from the votes sequence. This enables the votesWithRemovedCands\_IRV function to enforce that each preference list returned in newVotes must be the result of singleVoteWithRemovedCands\_IRV of the corresponding vote from the input. If empty votes got removed instead, it is hard to specify the expected result, because either the vote could become empty if all listed candidates should be removed, or the index of the corresponding new vote is different from its starting index. One minor disadvantage introduced by this decision is that the required vote count for an absolute majority can no longer use the total number of votes as a baseline. It rather requires the amount of non-empty votes; however, this can easily be computed.

## 4.3 Algorithm 2: Single Transferable Vote

Algorithm. The Single Transferable Vote system extends the idea of Instant-Runoff Voting to multi-seat elections. It ensures proportional representation by redistributing surplus votes from already elected candidates and eliminating the lowest-scoring candidates until all seats are filled.

The algorithm operates on a list of candidates ( seq&lt;nat&gt; ) and a list of votes ( Votes\_PreferenceList , see Sect. 4.1) without empty ballots. Candidates are represented as a sequence to enable deterministic tie-breaking: if multiple candidates obtain the same number of votes, the candidate appearing earlier in the sequence is selected for elimination or surplus redistribution, ensuring deterministic behavior. The algorithm computes the subset of candidates that will occupy the specified number of seats. In this way, every candidate who was assigned a seat represents a winner. Furthermore, the method employs the AUTOFILL procedure, which assigns a seat to every remaining candidate and classifies them as winners if the number of remaining candidates equals the number of unassigned seats. The main steps are follows:

1. Count first-preference votes for each candidate.
2. If the number of remaining candidates equals the number of unfilled seats, assign one seat to each of them.
3. Otherwise, determine the candidate with the highest vote count.
4. If this candidate meets or exceeds the Droop quota ( | ùëâùëúùë°ùëíùë† | ùë†ùëíùëéùë°ùë† + 1 + 1 ) , classify them as elected, redistribute their surplus votes proportionally and remove them from the list of votes and candidates.
5. If no candidate reaches the quota, eliminate the lowestscoring candidate, redistribute their votes and remove them from the list of votes and candidates.
6. If at least one seat remains unassigned, return to step 2. Otherwise, the winners have been determined.

Specification. The method SingleTransferableVote , shown in Fig. 1, computes the result of a multi-seat election and returns the elected candidates. The preconditions of the SingleTransferableVote method enforce that all votes are non-empty, contain only registered candidates, and have no duplicates. Additionally, the candidate list must not be empty or contain duplicates, and the number of seats to be filled must not exceed the number of candidates.

Since the algorithm includes the AUTOFILL procedure, the wrapper method distinguishes between candidates elected through quota classification and those selected by AUTOFILL. This separation preserves the order of quota winners according to the time of their classification, which enables the verification of further properties.

Under these conditions, the postconditions ensure that all winners originate from the list of registered candidates, and that the total number of winners-both quota winners ( W ) and AUTOFILL winners ( Rest )-equals the available number of seats (line 64). Furthermore, the sequences W and Rest are proven to be disjoint, and each candidate in W has at least one supporting vote (line 65) and reaches the quota at classification (line 66). The postcondition used to verify this property states that every winner c contained in W has an associated vote list, candidate list, and factor list, ensuring that its score computed from these is at least the quota.

To support this verification, the wrapper method records each classification step in stateSet , which is a sequence of triples containing the current vote list, factor list, and candidate list at the time of classification. Thus, every candidate c at a valid index i in W has a corresponding state in stateSet at the same index. This variable is used solely for verification and is omitted from the compiled code; it can be seen as a witness for the correct execution of the algorithm.

The method TransferVotes , shown in Fig. 1, ensures correct proportional redistribution of votes. Here, F represents the factor list, q the quota, and m the total votes of candidate c . If a candidate has not reached the quota, the factor of every transferable vote with the given candidate as first preference is carried over unchanged into the output factor list (line 93); otherwise, the factor of every transferable vote with the given candidate as first preference is adjusted by the ratio of surplus to total votes and placed in the new factor list (line 94). In this postcondition, the difference m-q represents the number of surplus votes, whereas the function getIndicesSet(...) computes a set of votes containing the candidate c as first preference, and the cardinality of this set corresponds to the total number of votes achieved by c . Votes that become empty are treated as non-transferable.

Implementation Details. The algorithm is implemented in a modular manner, with sub-methods for candidate elimination, vote evaluation, candidate search, vote redistribution,

```
55 type Triple = (Votes_PreferenceList ,seq<real>,seq<nat>) 56 predicate ValidInputsSTV(V : Votes_PreferenceList , C : seq<nat >){ 57 (0 < |C| && (forall c :: c in C ==> multiset(C)[c] == 1) && (forall i :: 0 <= i < |V| ==> V[i] != []) 58 && (forall v,c :: v in V && c in v ==> (c in C && multiset(v)[c] == 1))} 59 60 method SingleTransferableVote(V : Votes_PreferenceList , C : seq<nat>, s: nat) 61 returns (W : seq<nat>, Rest : seq<nat>, stateSet : seq<Triple >) 62 requires s <= |C| 63 requires ValidInputsSTV(V, C) 64 ensures |W| + |Rest| == s 65 ensures forall c :: c in W ==> exists v :: v in V && c in v 66 ensures forall i :: 0 <= i < |W| ==> 67 calculateTotalValue(stateSet[i].0, stateSet[i].2, stateSet[i].1, W[i]) 68 >= ((((|V| as real)/(s + 1) as real)) + 1.0).Floor as real 69 { 70 var q := (((((|V| as real)/ (s + 1) as real)) + 1.0).Floor) as real; 71 W, Rest , stateSet := [], [], []; 72 var F : FactorList := seq(|V|, i => 1.0); 73 var F0, C0, V0 := F, C, V; 74 while |W| + |Rest| < s { 75 if |C0| == s-|W| { Rest := C0; } // Step 2 76 else { 77 // Create ranking R with first -preference votes for candidate (step 1), get maximum score from R 78 m := max(R.Values); 79 // Candidate did not achieve quota --> find the loser (step 5) 80 if m < q { m := min(R.Values); } 81 // Find the candidate c with score m 82 if m >= q { 83 W := W + [c]; stateSet := stateSet + [(V0, F0, C0)]; // classification in step 3 84 } 85 // Vote redistribution and elimination from step 4 and 5: remove the candidate c from C0, V0 and 86 // invoke TransferVotes() 87 }}} 88 89 method TransferVotes(V : seq<seq<nat>>, F : seq<real>, c: nat, q : real , m : real) 90 returns (A0: (Votes_PreferenceList , FactorList)) 91 requires |V| == |F| 92 requires m > 0.0 ==> exists i :: 0 <= i < |V| && V[i][0] == c 93 ensures forall i :: 0 <= i < |V| && V[i][0] == c && |V[i]| > 1 && !(m -q >= 0.0) ==> F[i] in A0.1 94 ensures forall i :: 0 <= i < |V| && V[i][0] == c && |V[i]| > 1 && m -q >= 0.0 ==> 95 F[i]*((m-q)/|getIndicesSet(V,c)| as real) in A0.1 96 {...}
```

Figure 1. Methods SingleTransferableVote and TransferVotes

and a wrapper method implementing STV by invoking the necessary sub-methods. Important design decisions were to separate quota winners from AUTOFILL winners, enabling verification of the stated correctness properties, and to record all classification steps in order to capture each candidate's score at the time of classification. This is outlined in Fig. 1.

## 5 Deployment as Web Application

Multiple approaches and technologies were used for the implementation of a service that uses verified Dafny code at its core to hold elections online. Dafny was transpiled into the programming language Go to be used in a gRPC server [14] 3 and into C# for use in a Blazor Server app [5]. 4 Since Blazor is already well documented by Microsoft, we will focus on the architecture behind our gRPC server.

Architecture. The architecture (see Fig. 2) of the gRPC Go backend is similar to an onion architecture. The dependencies only flow outward; e.g., the domain logic (Use case

3 Currently hosted on https://eldarica.org/eins/

4 Currently hosted on https://eldarica.org/superior/

Figure 2. The architecture of the Go backend

<!-- image -->

Layer) can use the data loaders, but the database cannot depend on the fact that gRPC is used instead of a REST API. The different layers are as follows (with the outermost first):

- API Layer: Implements the gRPC functions defined by a Protobuf.
- Use case Layer: Contains domain logic in a broad sense. Also glues together low-level logic calls and data calls.
- Data Layer: Provides functions to interact with the database as well as data objects.
- Low-level Logic Layer: Contains independent lowlevel functions, such as password hashing. The formally verified voting algorithms with their caller functions are also included in this layer.

Enforcement of Preconditions. For the enforcement of preconditions, two distinct approaches have been used in the different backends.

The first approach is that preconditions are checked before the transpiled Dafny code is called. This allows the code to be optimized by hand, and if a check fails, an appropriate error message and behavior can be triggered. However, the main disadvantage is that the enforcing code needs to be checked and tested rigorously, because if there is a bug, the Dafny code might not perform as expected. This approach was used only in the Go implementation.

The second approach is that Dafny is solely responsible for enforcement at runtime via the expect keyword. If any precondition in Dafny does not hold, the transpiled code throws a Dafny.HaltException in C# or a runtime panic in Go, which is then caught. The exception message is customizable and thus increases the informational value, for example in server log files. A main disadvantage is that the Dafny library is a black box for the server, which must blindly trust that it executes correctly. It is also important that the runtime check ( expect ) and the formal preconditions ( requires ) are rigorously checked to ensure that they are consistent. This approach was used in both implementations.

Handling of Invalid Elections. If a post- or precondition does not hold, the server either stops the evaluation before the transpiled Dafny code is called or catches an exception or panic afterwards. The election is then deleted from the database and an e-mail is sent to all registered voters for complete transparency.

## 6 Lessons Learned

Focus on Simplicity. Keeping implementation and specification as simple as possible was a huge help in many cases, for instance when decoding the votes for the scoring voting systems where each candidate can be assigned a score. Initially, this was done as a sequence of tuples, which contained the candidate and their score. However, using a map from candidates to their scores simplified preconditions, because it was no longer required to check if a candidate appears multiple times in a vote. Furthermore, being able to better access the score of a candidate in a vote helped in the formulation of related pre- and postconditions and saved considerable work elsewhere, as one fewer precondition needed to be proven in order to call different methods. Another example is explained in Sect. 4.2, choosing to keep empty votes as empty lists when removing candidates from votes.

Performance and Scalability. Reasoning about properties of voting algorithms frequently required reasoning about entire collections, such as all candidates or all votes. Consequently, method contracts and invariants relied heavily on quantified statements, slowing the interactive verification process down and leading to numerous solver timeouts. To overcome this hurdle, we introduced a temporary assume false statement to incrementally verify methods. This statement allows the solver to focus only on the logic preceding the statement by causing all logic following it to be trivially true. Our process now involved progressively moving this statement downwards through the method body until the entire method was proven and the assume could be removed. Furthermore, we guided the solver through difficult proofs by introducing strategic assert statements to speed up verification.

Separately, we identified a significant performance issue related to Dafny's process management. To check satisfiability of a program, Dafny runs Z3 Theorem Prover processes in the background. We observed that after a verification run finished, according to Dafny, some of these processes would not always terminate, especially after rapid code changes. While these orphaned processes would not influence future verification runs, their accumulation caused excessive memory consumption and high CPU loads, impacting the overall system performance heavily. We found manually terminating the rogue Z3 processes through the operating system's task manager after a few verification runs to be the most effective solution.

Automation and Manual Intervention. Some properties that are intuitively obvious for humans required manual guidance for the underlying solver via specific assert statements or detailed lemma . Pinpointing the exact 'obvious' fact the solver was missing turned out to be an unexpected challenge by itself. The following code snippet illustrates this. Here, ùëÜ is a sequence of some kind:

```
var A:= S[..|S|]; assert S == S[..|S|]; //necessary assert multiset(S) == multiset(A);
```

For a human, it is obvious that ùê¥ and ùëÜ are identical and share the same multiset , but the solver cannot prove the final assertion without adding the intermediate one.

## 7 Conclusions and Future Work

In this paper, we have presented a library of four prominent voting algorithms and verified their key postconditions within the Dafny framework, focusing in detail on InstantRunoff Voting and Single Transferable Vote. These verified algorithms serve as the trusted core for our deployed e-voting websites. The code base has been made publicly available [6].

Immediate next steps for further development of our work are to verify more postconditions and fairness criteria for the existing algorithms using our code as a baseline. A more advanced goal is the expansion of the collection of verified algorithms using our approach. This could include a different social choice function like a Condorcet method [12].

Acknowledgments. We want to thank the anonymous reviewers for helpful feedback. This work was supported by the COST action CA20111 EuroProofNet and by the Swedish Research Council (VR) under grant 2021-06327.

## References

- [1] Mart√≠n Abadi and C√©dric Fournet. 2001. Mobile values, new names, and secure communication. In POPL . ACM, 104-115. doi: 10.1145/ 360204.360213
- [2] R. Michael Alvarez, Thad E. Hall, and Alexander H. Trechsel. 2014. Internet Voting and Democracy in the Digital Era . Routledge.
- [3] J. M. Baldwin. 1926. The Technique of the Nanson Preferential Majority System of Election. Transactions of the Royal Society of South Australia 50 (1926), 245-254.
- [4] Sevdenur Baloglu, Sergiu Bursuc, Sjouke Mauw, and Jun Pang. 2024. Formal Verification and Solutions for Estonian E-Voting. In AsiaCCS . ACM, 728-741. doi: 10.1145/3634737.3657009
- [5] blazor-doc 2025. https://learn.microsoft.com/de-de/aspnet/core/ blazor/?view=aspnetcore-9.0
- [6] Robert B√ºttner, Fabian Franz Die√ül, Patrick Janoschek, Ivana Kostadinovic, Henrik Oback, Kilian Vo√ü, Franziska Alber, Roland Herrmann, Sibylle M√∂hle, and Philipp R√ºmmer. 2025. Verification of E-Voting Algorithms in Dafny . https://github.com/uuverifiers/e-voting
- [7] Stefano Campanelli, Alessandro Falleni, Fabio Martinelli, Marinella Petrocchi, and Anna Vaccarelli. 2008. Mobile Implementation and Formal Verification of an e-Voting System. In ICIW . IEEE Computer Society, 476-481. doi: 10.1109/ICIW.2008.77
- [8] V√©ronique Cortier and Cyrille Wiedling. 2012. A Formal Analysis of the Norwegian E-voting Protocol. In POST (Lecture Notes in Computer Science, Vol. 7215) . Springer, 109-128. doi: 10.1007/978-3-642-28641-4\_7
- [9] Leonardo M. de Moura, Soonho Kong, Jeremy Avigad, Floris van Doorn, and Jakob von Raumer. 2015. The Lean Theorem Prover (System Description). In CADE (Lecture Notes in Computer Science, Vol. 9195) . Springer, 378-388. doi: 10.1007/978-3-319-21401-6\_26
- [10] Peter Emerson. 2013. The Original Borda Count and Partial Voting. Social Choice and Welfare 40, 2 (2013), 353-358.
- [11] David M. Farrell and Ian McAllister. 2011. The Australian Electoral System: Origins, Variations and Consequences . UNSW Press.
- [12] Peter C. Fishburn. 1977. Condorcet Social Choice Functions. SIAM J. Appl. Math. 33, 3 (1977), 469-489. doi: 10.1137/0133030
- [13] Anthony Di Franco, Andrew Petro, Emmett Shear, and Vladimir Vladimirov. 2004. Small vote manipulations can swing elections. Commun. ACM 47, 10 (2004), 43-45. doi: 10.1145/1022594.1022621
- [14] Go-grpc 2023. https://grpc.io/docs/languages/go/
- [15] J. B. Gregory. 1880. The Transferable Vote: A Method of Proportional Representation. Transactions and Proceedings of the Royal Society of Tasmania 1878-1880 (1880), 145-152.
- [16] Wesley H. Holliday, Chase Norman, and Eric Pacuit. 2021. Voting Theory in the Lean Theorem Prover. In LORI (Lecture Notes in Computer Science, Vol. 13039) . Springer, 111-127. doi: 10.1007/978-3-030-88708-7\_9
- [17] Kurt Jensen and Lars M. Kristensen. 2009. Formal Definition of Hierarchical Coloured Petri Nets . Springer Berlin Heidelberg, 127-149. doi: 10.1007/b95112\_6
- [18] K. Rustan M. Leino. 2010. Dafny: An Automatic Program Verifier for Functional Correctness. In Logic for Programming, Artificial Intelligence, and Reasoning - 16th International Conference, LPAR-16, Dakar, Senegal, April 25-May 1, 2010, Revised Selected Papers (Lecture Notes in Computer Science, Vol. 6355) , Edmund M. Clarke and Andrei Voronkov (Eds.). Springer, 348-370. doi: 10.1007/978-3-642-17511-4\_20
- [19] Fabio Martinelli. 2008. Partial Model Checking Security Analyzer PaMoChSA (v1.0). https://webhost.services.iit.cnr.it/staff/fabio. martinelli/pamochsa.htm
- [20] Said Meghzili, Allaoua Chaoui, Raida Elmansouri, Bardis Nadjla Alloui, and Amina Bouabsa. 2022. Formal Verification and Implementation of an E-Voting System. Int. J. Softw. Innov. 10, 1 (2022), 1-22. doi: 10. 4018/IJSI.309731
- [21] Simon Meier, Benedikt Schmidt, Cas Cremers, and David A. Basin. 2013. The TAMARIN Prover for the Symbolic Analysis of Security Protocols. In CAV (Lecture Notes in Computer Science, Vol. 8044) . Springer, 696-701. doi: 10.1007/978-3-642-39799-8\_48
- [22] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. 2002. Isabelle/HOL - A Proof Assistant for Higher-Order Logic . Lecture Notes in Computer Science, Vol. 2283. Springer. doi: 10.1007/3-540-45949-9
- [23] Hannu Nurmi. 1987. Comparing Voting Systems . D. Reidel.
- [24] Kellie Ottoboni and Philip B. Stark. 2019. Election Integrity and Electronic Voting Machines in 2018 Georgia, USA. In Electronic Voting - 4th International Joint Conference, E-Vote-ID 2019, Bregenz, Austria, October 1-4, 2019, Proceedings (Lecture Notes in Computer Science, Vol. 11759) , Robert Krimmer, Melanie Volkamer, V√©ronique Cortier, Bernhard Beckert, Ralf K√ºsters, Uwe Serd√ºlt, and David Duenas-Cid (Eds.). Springer, 166-182. doi: 10.1007/978-3-030-30625-0\_11
- [25] Salvatore F. Rossetta. 2024. Formalization and Verification of Proportional Representation Voting Systems using Isabelle/HOL: A Study of D'Hondt and Sainte-Lagu√´ Methods . Master's thesis. Politecnico di Torino. https://webthesis.biblio.polito.it/33188/
- [26] Carsten Sch√ºrmann. 2024. Social Elections. In E-Vote-ID 2024 . Gesellschaft f√ºr Informatik, Bonn, 127-139. doi: 10.18420/e-vote-id2024\_09
- [27] Warren D. Smith. 2000. Range Voting. Available at https://rangevoting. org .
- [28] T. Nicolaus Tideman. 1995. The Single Transferable Vote. Journal of Economic Perspectives 9, 1 (1995), 27-38.
- [29] T. Nicolaus Tideman. 2006. Collective Decisions and Voting: The Potential for Public Choice . Ashgate.
- [30] Maria-Victoria Vladucu, Ziqian Dong, Jorge Medina, and Roberto Rojas-Cessa. 2023. E-Voting Meets Blockchain: A Survey. IEEE Access 11 (2023), 23293-23308. doi: 10.1109/ACCESS.2023.3253682
- [31] Christian Wimmer, Felix Hirsch, Andreas Rieger, Sergey Tverdyshev, and Artsiom Yautsiukhin. 2019. Formal Verification of E-Voting: From Requirements to Source Code. In International Conference on E-Voting and Identity . 106-121.